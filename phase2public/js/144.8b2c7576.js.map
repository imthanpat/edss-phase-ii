{"version":3,"file":"js/144.8b2c7576.js","mappings":"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","sources":["webpack://edss-vue-ii/../../../src/components/VAutocomplete/VAutocomplete.tsx","webpack://edss-vue-ii/../../../src/components/VTabs/VTab.tsx","webpack://edss-vue-ii/../../../src/components/VSlideGroup/helpers.ts","webpack://edss-vue-ii/../../../src/components/VSlideGroup/VSlideGroup.tsx","webpack://edss-vue-ii/../../../src/components/VTabs/VTabs.tsx","webpack://edss-vue-ii/../../../src/components/VTabs/shared.ts","webpack://edss-vue-ii/../../../src/components/VWindow/VWindow.tsx","webpack://edss-vue-ii/../../../src/components/VWindow/VWindowItem.tsx","webpack://edss-vue-ii/../../../src/directives/touch/index.ts"],"sourcesContent":["// Styles\nimport './VAutocomplete.sass'\n\n// Components\nimport { makeSelectProps } from '@/components/VSelect/VSelect'\nimport { VCheckboxBtn } from '@/components/VCheckbox'\nimport { VChip } from '@/components/VChip'\nimport { VDefaultsProvider } from '@/components/VDefaultsProvider'\nimport { VList, VListItem } from '@/components/VList'\nimport { VMenu } from '@/components/VMenu'\nimport { VTextField } from '@/components/VTextField'\n\n// Composables\nimport { makeFilterProps, useFilter } from '@/composables/filter'\nimport { makeTransitionProps } from '@/composables/transition'\nimport { forwardRefs } from '@/composables/forwardRefs'\nimport { useItems } from '@/composables/items'\nimport { useLocale } from '@/composables/locale'\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utility\nimport { computed, mergeProps, nextTick, ref, watch } from 'vue'\nimport { genericComponent, useRender, wrapInArray } from '@/util'\n\n// Types\nimport type { FilterMatch } from '@/composables/filter'\nimport type { MakeSlots } from '@/util'\nimport type { VFieldSlots } from '@/components/VField/VField'\nimport type { VInputSlots } from '@/components/VInput/VInput'\n\nfunction highlightResult (text: string, matches: FilterMatch, length: number) {\n  if (Array.isArray(matches)) throw new Error('Multiple matches is not implemented')\n\n  return typeof matches === 'number' && ~matches\n    ? (\n      <>\n        <span class=\"v-autocomplete__unmask\">{ text.substr(0, matches) }</span>\n        <span class=\"v-autocomplete__mask\">{ text.substr(matches, length) }</span>\n        <span class=\"v-autocomplete__unmask\">{ text.substr(matches + length) }</span>\n      </>\n    )\n    : text\n}\n\ntype Primitive = string | number | boolean | symbol\n\ntype Val <T, ReturnObject extends boolean> = T extends Primitive\n  ? T\n  : (ReturnObject extends true ? T : any)\n\ntype Value <T, ReturnObject extends boolean, Multiple extends boolean> =\n  Multiple extends true\n    ? Val<T, ReturnObject>[]\n    : Val<T, ReturnObject>\n\nexport const VAutocomplete = genericComponent<new <\n  T,\n  ReturnObject extends boolean = false,\n  Multiple extends boolean = false,\n  V extends Value<T, ReturnObject, Multiple> = Value<T, ReturnObject, Multiple>\n>() => {\n  $props: {\n    items?: readonly T[]\n    returnObject?: ReturnObject\n    multiple?: Multiple\n    modelValue?: Readonly<V>\n    'onUpdate:modelValue'?: (val: V) => void\n  }\n  $slots: Omit<VInputSlots & VFieldSlots, 'default'> & MakeSlots<{\n    item: [{ item: T, index: number, props: Record<string, unknown> }]\n    chip: [{ item: T, index: number, props: Record<string, unknown> }]\n    selection: [{ item: T, index: number }]\n    'no-data': []\n  }>\n}>()({\n  name: 'VAutocomplete',\n\n  props: {\n    // TODO: implement post keyboard support\n    // autoSelectFirst: Boolean,\n    search: String,\n\n    ...makeFilterProps({ filterKeys: ['title'] }),\n    ...makeSelectProps(),\n    ...makeTransitionProps({ transition: false }),\n  },\n\n  emits: {\n    'update:search': (val: any) => true,\n    'update:modelValue': (val: any) => true,\n    'update:menu': (val: boolean) => true,\n  },\n\n  setup (props, { slots }) {\n    const { t } = useLocale()\n    const vTextFieldRef = ref()\n    const isFocused = ref(false)\n    const isPristine = ref(true)\n    const menu = useProxiedModel(props, 'menu')\n    const { items, transformIn, transformOut } = useItems(props)\n    const search = useProxiedModel(props, 'search', '')\n    const model = useProxiedModel(\n      props,\n      'modelValue',\n      [],\n      v => transformIn(wrapInArray(v)),\n      v => {\n        const transformed = transformOut(v)\n        return props.multiple ? transformed : (transformed[0] ?? null)\n      }\n    )\n    const { filteredItems } = useFilter(props, items, computed(() => isPristine.value ? undefined : search.value))\n    const selections = computed(() => {\n      return model.value.map(v => {\n        return items.value.find(item => item.value === v.value) || v\n      })\n    })\n    const selected = computed(() => selections.value.map(selection => selection.props.value))\n\n    function onClear (e: MouseEvent) {\n      model.value = []\n\n      if (props.openOnClear) {\n        menu.value = true\n      }\n\n      search.value = ''\n    }\n    function onClickControl () {\n      if (props.hideNoData && !filteredItems.value.length) return\n\n      menu.value = true\n    }\n    function onKeydown (e: KeyboardEvent) {\n      if (['Enter', 'ArrowDown'].includes(e.key)) {\n        menu.value = true\n      }\n\n      if (['Escape'].includes(e.key)) {\n        menu.value = false\n      }\n\n      if (['Enter', 'Escape', 'Tab'].includes(e.key)) {\n        isPristine.value = true\n      }\n    }\n\n    function onInput (e: InputEvent) {\n      search.value = (e.target as HTMLInputElement).value\n    }\n\n    function onAfterLeave () {\n      if (isFocused.value) isPristine.value = true\n    }\n\n    const isSelecting = ref(false)\n\n    function select (item: any) {\n      if (props.multiple) {\n        const index = selected.value.findIndex(selection => selection === item.value)\n\n        if (index === -1) {\n          model.value = [...model.value, item]\n          search.value = ''\n        } else {\n          const value = [...model.value]\n          value.splice(index, 1)\n          model.value = value\n        }\n      } else {\n        model.value = [item]\n\n        isSelecting.value = true\n\n        search.value = item.title\n        menu.value = false\n        isPristine.value = true\n\n        nextTick(() => (isSelecting.value = false))\n      }\n    }\n\n    watch(isFocused, val => {\n      if (val) {\n        isSelecting.value = true\n        search.value = props.multiple ? '' : String(selections.value.at(-1)?.props.title ?? '')\n        isPristine.value = true\n\n        nextTick(() => isSelecting.value = false)\n      } else {\n        menu.value = false\n        search.value = ''\n      }\n    })\n\n    watch(search, val => {\n      if (!isFocused.value || isSelecting.value) return\n\n      if (val) menu.value = true\n\n      isPristine.value = !val\n    })\n\n    useRender(() => {\n      const hasChips = !!(props.chips || slots.chip)\n\n      return (\n        <VTextField\n          ref={ vTextFieldRef }\n          modelValue={ search.value }\n          onUpdate:modelValue={ v => { if (v == null) model.value = [] } }\n          validationValue={ props.modelValue }\n          onInput={ onInput }\n          class={[\n            'v-autocomplete',\n            {\n              'v-autocomplete--active-menu': menu.value,\n              'v-autocomplete--chips': !!props.chips,\n              [`v-autocomplete--${props.multiple ? 'multiple' : 'single'}`]: true,\n            },\n          ]}\n          appendInnerIcon={ props.menuIcon }\n          onClick:clear={ onClear }\n          onClick:control={ onClickControl }\n          onClick:input={ onClickControl }\n          onFocus={ () => isFocused.value = true }\n          onBlur={ () => isFocused.value = false }\n          onKeydown={ onKeydown }\n        >\n          {{\n            ...slots,\n            default: () => (\n              <>\n                <VMenu\n                  v-model={ menu.value }\n                  activator=\"parent\"\n                  contentClass=\"v-autocomplete__content\"\n                  eager={ props.eager }\n                  openOnClick={ false }\n                  closeOnContentClick={ false }\n                  transition={ props.transition }\n                  onAfterLeave={ onAfterLeave }\n                  { ...props.menuProps }\n                >\n                  <VList\n                    selected={ selected.value }\n                    selectStrategy={ props.multiple ? 'independent' : 'single-independent' }\n                    onMousedown={ (e: MouseEvent) => e.preventDefault() }\n                  >\n                    { !filteredItems.value.length && !props.hideNoData && (slots['no-data']?.() ?? (\n                      <VListItem title={ t(props.noDataText) } />\n                    )) }\n\n                    { filteredItems.value.map(({ item, matches }, index) => slots.item?.({\n                      item,\n                      index,\n                      props: mergeProps(item.props, { onClick: () => select(item) }),\n                    }) ?? (\n                      <VListItem\n                        key={ index }\n                        { ...item.props }\n                        onClick={ () => select(item) }\n                      >\n                        {{\n                          prepend: ({ isSelected }) => props.multiple && !props.hideSelected ? (\n                            <VCheckboxBtn modelValue={ isSelected } ripple={ false } />\n                          ) : undefined,\n                          title: () => {\n                            return isPristine.value\n                              ? item.title\n                              : highlightResult(item.title, matches.title, search.value?.length ?? 0)\n                          },\n                        }}\n                      </VListItem>\n                    )) }\n                  </VList>\n                </VMenu>\n\n                { selections.value.map((item, index) => {\n                  function onChipClose (e: Event) {\n                    e.stopPropagation()\n                    e.preventDefault()\n\n                    select(item)\n                  }\n\n                  const slotProps = {\n                    'onClick:close': onChipClose,\n                    modelValue: true,\n                  }\n\n                  return (\n                    <div key={ index } class=\"v-autocomplete__selection\">\n                      { hasChips ? (\n                        <VDefaultsProvider\n                          defaults={{\n                            VChip: {\n                              closable: props.closableChips,\n                              size: 'small',\n                              text: item.title,\n                            },\n                          }}\n                        >\n                          { slots.chip\n                            ? slots.chip({ item, index, props: slotProps })\n                            : (<VChip { ...slotProps } />)\n                          }\n                        </VDefaultsProvider>\n                      ) : (\n                        slots.selection\n                          ? slots.selection({ item, index })\n                          : (\n                            <span class=\"v-autocomplete__selection-text\">\n                              { item.title }\n                              { props.multiple && (index < selections.value.length - 1) && (\n                                <span class=\"v-autocomplete__selection-comma\">,</span>\n                              ) }\n                            </span>\n                          )\n                      )}\n                    </div>\n                  )\n                }) }\n              </>\n            ),\n          }}\n        </VTextField>\n      )\n    })\n\n    return forwardRefs({\n      isFocused,\n      isPristine,\n      menu,\n      search,\n      filteredItems,\n      select,\n    }, vTextFieldRef)\n  },\n})\n\nexport type VAutocomplete = InstanceType<typeof VAutocomplete>\n","// Styles\nimport './VTab.sass'\n\n// Components\nimport { VBtn } from '@/components/VBtn'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeGroupItemProps } from '@/composables/group'\nimport { makeRouterProps } from '@/composables/router'\nimport { makeTagProps } from '@/composables/tag'\nimport { makeThemeProps } from '@/composables/theme'\nimport { useTextColor } from '@/composables/color'\n\n// Utilities\nimport { computed, ref } from 'vue'\nimport { defineComponent, pick, standardEasing, useRender } from '@/util'\n\n// Types\nimport { VTabsSymbol } from './shared'\nimport type { PropType } from 'vue'\n\nexport const VTab = defineComponent({\n  name: 'VTab',\n\n  props: {\n    fixed: Boolean,\n    icon: [Boolean, String, Function, Object] as PropType<boolean | IconValue>,\n    prependIcon: IconValue,\n    appendIcon: IconValue,\n\n    stacked: Boolean,\n    title: String,\n\n    ripple: {\n      type: Boolean,\n      default: true,\n    },\n    color: String,\n    sliderColor: String,\n    hideSlider: Boolean,\n\n    direction: {\n      type: String as PropType<'horizontal' | 'vertical'>,\n      default: 'horizontal',\n    },\n\n    ...makeTagProps(),\n    ...makeRouterProps(),\n    ...makeGroupItemProps({\n      selectedClass: 'v-tab--selected',\n    }),\n    ...makeThemeProps(),\n  },\n\n  setup (props, { slots, attrs }) {\n    const { textColorClasses: sliderColorClasses, textColorStyles: sliderColorStyles } = useTextColor(props, 'sliderColor')\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n    const isSelected = ref(false)\n\n    const rootEl = ref<VBtn>()\n    const sliderEl = ref<HTMLElement>()\n\n    function updateSlider ({ value }: { value: boolean }) {\n      isSelected.value = value\n\n      if (value) {\n        const prevEl: HTMLElement | undefined = rootEl.value?.$el.parentElement?.querySelector('.v-tab--selected .v-tab__slider')\n        const nextEl = sliderEl.value\n\n        if (!prevEl || !nextEl) return\n\n        const color = getComputedStyle(prevEl).color\n\n        const prevBox = prevEl.getBoundingClientRect()\n        const nextBox = nextEl.getBoundingClientRect()\n\n        const xy = isHorizontal.value ? 'x' : 'y'\n        const XY = isHorizontal.value ? 'X' : 'Y'\n        const rightBottom = isHorizontal.value ? 'right' : 'bottom'\n        const widthHeight = isHorizontal.value ? 'width' : 'height'\n\n        const prevPos = prevBox[xy]\n        const nextPos = nextBox[xy]\n        const delta = prevPos > nextPos\n          ? prevBox[rightBottom] - nextBox[rightBottom]\n          : prevBox[xy] - nextBox[xy]\n        const origin =\n          Math.sign(delta) > 0 ? (isHorizontal.value ? 'right' : 'bottom')\n          : Math.sign(delta) < 0 ? (isHorizontal.value ? 'left' : 'top')\n          : 'center'\n        const size = Math.abs(delta) + (Math.sign(delta) < 0 ? prevBox[widthHeight] : nextBox[widthHeight])\n        const scale = size / Math.max(prevBox[widthHeight], nextBox[widthHeight])\n        const initialScale = prevBox[widthHeight] / nextBox[widthHeight]\n\n        const sigma = 1.5\n        nextEl.animate({\n          backgroundColor: [color, ''],\n          transform: [\n            `translate${XY}(${delta}px) scale${XY}(${initialScale})`,\n            `translate${XY}(${delta / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`,\n            '',\n          ],\n          transformOrigin: Array(3).fill(origin),\n        }, {\n          duration: 225,\n          easing: standardEasing,\n        })\n      }\n    }\n\n    useRender(() => {\n      const [btnProps] = pick(props, [\n        'href',\n        'to',\n        'replace',\n        'icon',\n        'stacked',\n        'prependIcon',\n        'appendIcon',\n        'ripple',\n        'theme',\n        'disabled',\n        'selectedClass',\n        'value',\n        'color',\n      ])\n\n      return (\n        <VBtn\n          _as=\"VTab\"\n          symbol={ VTabsSymbol }\n          ref={ rootEl }\n          class={[\n            'v-tab',\n          ]}\n          tabindex={ isSelected.value ? 0 : -1 }\n          role=\"tab\"\n          aria-selected={ String(isSelected.value) }\n          block={ props.fixed }\n          maxWidth={ props.fixed ? 300 : undefined }\n          variant=\"text\"\n          rounded={ 0 }\n          { ...btnProps }\n          { ...attrs }\n          onGroup:selected={ updateSlider }\n        >\n          { slots.default ? slots.default() : props.title }\n          { !props.hideSlider && (\n            <div\n              ref={ sliderEl }\n              class={[\n                'v-tab__slider',\n                sliderColorClasses.value,\n              ]}\n              style={ sliderColorStyles.value }\n            />\n          ) }\n        </VBtn>\n      )\n    })\n\n    return {}\n  },\n})\n\nexport type VTab = InstanceType<typeof VTab>\n","export function bias (val: number) {\n  const c = 0.501\n  const x = Math.abs(val)\n  return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1))\n}\n\nexport function calculateUpdatedOffset ({\n  selectedElement,\n  containerSize,\n  contentSize,\n  isRtl,\n  currentScrollOffset,\n  isHorizontal,\n}: {\n  selectedElement: HTMLElement\n  containerSize: number\n  contentSize: number\n  isRtl: boolean\n  currentScrollOffset: number\n  isHorizontal: boolean\n}): number {\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop\n  const adjustedOffsetStart = isRtl ? (contentSize - offsetStart - clientSize) : offsetStart\n\n  if (isRtl) {\n    currentScrollOffset = -currentScrollOffset\n  }\n\n  const totalSize = containerSize + currentScrollOffset\n  const itemOffset = clientSize + adjustedOffsetStart\n  const additionalOffset = clientSize * 0.4\n\n  if (adjustedOffsetStart <= currentScrollOffset) {\n    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0)\n  } else if (totalSize <= itemOffset) {\n    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize)\n  }\n\n  return isRtl ? -currentScrollOffset : currentScrollOffset\n}\n\nexport function calculateCenteredOffset ({\n  selectedElement,\n  containerSize,\n  contentSize,\n  isRtl,\n  isHorizontal,\n}: {\n  selectedElement: HTMLElement\n  containerSize: number\n  contentSize: number\n  isRtl: boolean\n  isHorizontal: boolean\n}): number {\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop\n\n  if (isRtl) {\n    const offsetCentered = contentSize - offsetStart - clientSize / 2 - containerSize / 2\n    return -Math.min(contentSize - containerSize, Math.max(0, offsetCentered))\n  } else {\n    const offsetCentered = offsetStart + clientSize / 2 - containerSize / 2\n    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered))\n  }\n}\n","// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { makeTagProps } from '@/composables/tag'\nimport { useDisplay } from '@/composables'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { useRtl } from '@/composables/rtl'\n\n// Utilities\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from './helpers'\nimport { clamp, defineComponent, IN_BROWSER, useRender } from '@/util'\nimport { computed, ref, watch } from 'vue'\n\n// Types\nimport type { GroupProvide } from '@/composables/group'\nimport type { InjectionKey } from 'vue'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\nexport const VSlideGroup = defineComponent({\n  name: 'VSlideGroup',\n\n  props: {\n    centerActive: Boolean,\n    direction: {\n      type: String,\n      default: 'horizontal',\n    },\n    symbol: {\n      type: null,\n      default: VSlideGroupSymbol,\n    },\n    nextIcon: {\n      type: IconValue,\n      default: '$next',\n    },\n    prevIcon: {\n      type: IconValue,\n      default: '$prev',\n    },\n    showArrows: {\n      type: [Boolean, String],\n      validator: (v: any) => (\n        typeof v === 'boolean' || [\n          'always',\n          'desktop',\n          'mobile',\n        ].includes(v)\n      ),\n    },\n\n    ...makeTagProps(),\n    ...makeGroupProps({\n      selectedClass: 'v-slide-group-item--active',\n    }),\n  },\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { mobile } = useDisplay()\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = ref(false)\n    const scrollOffset = ref(0)\n    const containerSize = ref(0)\n    const contentSize = ref(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value] as HTMLElement\n\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value,\n              })\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value,\n              })\n            }\n          }\n        })\n      })\n    }\n\n    const disableTransition = ref(false)\n\n    let startTouch = 0\n    let startOffset = 0\n\n    function onTouchstart (e: TouchEvent) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      startOffset = scrollOffset.value\n      startTouch = e.touches[0][sizeProperty]\n      disableTransition.value = true\n    }\n\n    function onTouchmove (e: TouchEvent) {\n      if (!isOverflowing.value) return\n\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      scrollOffset.value = startOffset + startTouch - e.touches[0][sizeProperty]\n    }\n\n    function onTouchend (e: TouchEvent) {\n      const maxScrollOffset = contentSize.value - containerSize.value\n\n      if (isRtl.value) {\n        if (scrollOffset.value > 0 || !isOverflowing.value) {\n          scrollOffset.value = 0\n        } else if (scrollOffset.value <= -maxScrollOffset) {\n          scrollOffset.value = -maxScrollOffset\n        }\n      } else {\n        if (scrollOffset.value < 0 || !isOverflowing.value) {\n          scrollOffset.value = 0\n        } else if (scrollOffset.value >= maxScrollOffset) {\n          scrollOffset.value = maxScrollOffset\n        }\n      }\n\n      disableTransition.value = false\n    }\n\n    function onScroll () {\n      containerRef.value && (containerRef.value.scrollLeft = 0)\n    }\n\n    const isFocused = ref(false)\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.value) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item as HTMLElement,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value,\n            })\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    function onFocus (e: FocusEvent) {\n      if (\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget as Node))\n      ) focus()\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.value) return\n\n      if (e.key === (isHorizontal.value ? 'ArrowRight' : 'ArrowDown')) {\n        focus('next')\n      } else if (e.key === (isHorizontal.value ? 'ArrowLeft' : 'ArrowUp')) {\n        focus('prev')\n      } else if (e.key === 'Home') {\n        focus('first')\n      } else if (e.key === 'End') {\n        focus('last')\n      }\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.value) return\n\n      if (!location) {\n        contentRef.value.querySelector('[tabindex]')\n        const focusable = [...contentRef.value.querySelectorAll(\n          'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        )].filter(el => !el.hasAttribute('disabled')) as HTMLElement[]\n        focusable[0]?.focus()\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('first')\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('last')\n      } else if (location === 'first') {\n        (contentRef.value.firstElementChild as HTMLElement)?.focus()\n      } else if (location === 'last') {\n        (contentRef.value.lastElementChild as HTMLElement)?.focus()\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const sign = isRtl.value ? -1 : 1\n      const newAbosluteOffset = sign * scrollOffset.value +\n        (location === 'prev' ? -1 : 1) * containerSize.value\n\n      scrollOffset.value = sign * clamp(newAbosluteOffset, 0, contentSize.value - containerSize.value)\n    }\n\n    const contentStyles = computed(() => {\n      const scrollAmount = scrollOffset.value <= 0\n        ? bias(-scrollOffset.value)\n        : scrollOffset.value > contentSize.value - containerSize.value\n          ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value)\n          : -scrollOffset.value\n\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : '',\n      }\n    })\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      return hasAffixes.value && scrollOffset.value > 0\n    })\n\n    const hasNext = computed(() => {\n      if (!hasAffixes.value) return false\n\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n        ]}\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onClick={ () => scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ props.prevIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            style={ contentStyles.value }\n            onTouchstartPassive={ onTouchstart }\n            onTouchmovePassive={ onTouchmove }\n            onTouchendPassive={ onTouchend }\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onClick={ () => scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ props.nextIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n","// Styles\nimport './VTabs.sass'\n\n// Components\nimport { VSlideGroup } from '@/components/VSlideGroup'\nimport { VTab } from './VTab'\n\n// Composables\nimport { makeDensityProps, useDensity } from '@/composables/density'\nimport { makeTagProps } from '@/composables/tag'\nimport { provideDefaults } from '@/composables/defaults'\nimport { useBackgroundColor } from '@/composables/color'\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, toRef } from 'vue'\nimport { defineComponent, useRender } from '@/util'\n\n// Types\nimport { VTabsSymbol } from './shared'\nimport type { PropType } from 'vue'\n\nexport type TabItem = string | Record<string, any>\n\nfunction parseItems (items: TabItem[] | undefined) {\n  if (!items) return []\n\n  return items.map(item => {\n    if (typeof item === 'string') return { title: item, value: item }\n\n    return item\n  })\n}\n\nexport const VTabs = defineComponent({\n  name: 'VTabs',\n\n  props: {\n    alignWithTitle: Boolean,\n    color: String,\n    direction: {\n      type: String as PropType<'horizontal' | 'vertical'>,\n      default: 'horizontal',\n    },\n    fixedTabs: Boolean,\n    items: {\n      type: Array as PropType<TabItem[]>,\n      default: () => ([]),\n    },\n    stacked: Boolean,\n    backgroundColor: String,\n    centered: Boolean,\n    grow: Boolean,\n    height: {\n      type: [Number, String],\n      default: undefined,\n    },\n    hideSlider: Boolean,\n    optional: Boolean,\n    end: Boolean,\n    sliderColor: String,\n    modelValue: null,\n\n    ...makeDensityProps(),\n    ...makeTagProps(),\n  },\n\n  emits: {\n    'update:modelValue': (v: unknown) => true,\n  },\n\n  setup (props, { slots }) {\n    const model = useProxiedModel(props, 'modelValue')\n    const parsedItems = computed(() => parseItems(props.items))\n    const { densityClasses } = useDensity(props)\n    const { backgroundColorClasses, backgroundColorStyles } = useBackgroundColor(toRef(props, 'backgroundColor'))\n\n    provideDefaults({\n      VTab: {\n        color: toRef(props, 'color'),\n        direction: toRef(props, 'direction'),\n        stacked: toRef(props, 'stacked'),\n        fixed: toRef(props, 'fixedTabs'),\n        sliderColor: toRef(props, 'sliderColor'),\n        hideSlider: toRef(props, 'hideSlider'),\n      },\n    })\n\n    useRender(() => (\n      <VSlideGroup\n        v-model={ model.value }\n        class={[\n          'v-tabs',\n          `v-tabs--${props.direction}`,\n          {\n            'v-tabs--align-with-title': props.alignWithTitle,\n            'v-tabs--centered': props.centered,\n            'v-tabs--fixed-tabs': props.fixedTabs,\n            'v-tabs--grow': props.grow,\n            'v-tabs--end': props.end,\n            'v-tabs--stacked': props.stacked,\n          },\n          densityClasses.value,\n          backgroundColorClasses.value,\n        ]}\n        style={backgroundColorStyles.value}\n        role=\"tablist\"\n        symbol={ VTabsSymbol }\n        mandatory=\"force\"\n        direction={ props.direction }\n      >\n        { slots.default ? slots.default() : parsedItems.value.map(item => (\n          <VTab { ...item } key={ item.title } />\n        )) }\n      </VSlideGroup>\n    ))\n\n    return {}\n  },\n})\n\nexport type VTabs = InstanceType<typeof VTabs>\n","import type { InjectionKey } from 'vue'\nimport type { GroupProvide } from '@/composables/group'\n\nexport const VTabsSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-tabs')\n","// Styles\nimport './VWindow.sass'\n\n// Components\nimport { VBtn } from '@/components/VBtn'\n\n// Directives\nimport { Touch } from '@/directives/touch'\n\n// Composables\nimport { makeTagProps } from '@/composables/tag'\nimport { makeThemeProps, provideTheme } from '@/composables/theme'\nimport { useGroup } from '@/composables/group'\nimport { useLocale } from '@/composables/locale'\nimport { useRtl } from '@/composables/rtl'\n\n// Utilities\nimport { computed, provide, ref, watch } from 'vue'\nimport { genericComponent, useRender } from '@/util'\n\n// Types\nimport type { ComputedRef, InjectionKey, PropType, Ref } from 'vue'\nimport type { GroupItemProvide, GroupProvide } from '@/composables/group'\nimport type { IconValue } from '@/composables/icons'\nimport type { MakeSlots } from '@/util'\nimport type { TouchHandlers } from '@/directives/touch'\n\ntype WindowProvide = {\n  transition: ComputedRef<undefined | string>\n  transitionCount: Ref<number>\n  transitionHeight: Ref<undefined | string>\n  isReversed: Ref<boolean>\n  rootRef: Ref<HTMLElement | undefined>\n}\n\ntype ControlProps = {\n  icon: IconValue\n  class: string\n  onClick: () => void\n  ariaLabel: string\n}\n\nexport const VWindowSymbol: InjectionKey<WindowProvide> = Symbol.for('vuetify:v-window')\nexport const VWindowGroupSymbol: InjectionKey<GroupItemProvide> = Symbol.for('vuetify:v-window-group')\n\nexport const VWindow = genericComponent<new () => {\n  $slots: MakeSlots<{\n    default: [{ group: GroupProvide }]\n    additional: [{ group: GroupProvide }]\n    prev: [{ props: ControlProps }]\n    next: [{ props: ControlProps }]\n  }>\n}>()({\n  name: 'VWindow',\n\n  directives: {\n    Touch,\n  },\n\n  props: {\n    continuous: Boolean,\n    nextIcon: {\n      type: [Boolean, String, Function, Object] as PropType<IconValue>,\n      default: '$next',\n    },\n    prevIcon: {\n      type: [Boolean, String, Function, Object] as PropType<IconValue>,\n      default: '$prev',\n    },\n    reverse: Boolean,\n    showArrows: {\n      type: [Boolean, String],\n      validator: (v: any) => typeof v === 'boolean' || v === 'hover',\n    },\n    touch: {\n      type: [Object, Boolean] as PropType<boolean | TouchHandlers>,\n      default: undefined,\n    },\n    direction: {\n      type: String,\n      default: 'horizontal',\n    },\n\n    modelValue: null,\n    disabled: Boolean,\n    selectedClass: {\n      type: String,\n      default: 'v-window-item--active',\n    },\n    // TODO: mandatory should probably not be exposed but do this for now\n    mandatory: {\n      default: 'force' as const,\n    },\n\n    ...makeTagProps(),\n    ...makeThemeProps(),\n  },\n\n  emits: {\n    'update:modelValue': (v: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { themeClasses } = provideTheme(props)\n    const { isRtl } = useRtl()\n    const { t } = useLocale()\n\n    const group = useGroup(props, VWindowGroupSymbol)\n\n    const rootRef = ref()\n    const isRtlReverse = computed(() => isRtl.value ? !props.reverse : props.reverse)\n    const isReversed = ref(false)\n    const transition = computed(() => {\n      const axis = props.direction === 'vertical' ? 'y' : 'x'\n      const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value\n      const direction = reverse ? '-reverse' : ''\n\n      return `v-window-${axis}${direction}-transition`\n    })\n    const transitionCount = ref(0)\n    const transitionHeight = ref<undefined | string>(undefined)\n\n    const activeIndex = computed(() => {\n      return group.items.value.findIndex(item => group.selected.value.includes(item.id))\n    })\n\n    watch(activeIndex, (newVal, oldVal) => {\n      const itemsLength = group.items.value.length\n      const lastIndex = itemsLength - 1\n\n      if (itemsLength <= 2) {\n        isReversed.value = newVal < oldVal\n      } else if (newVal === lastIndex && oldVal === 0) {\n        isReversed.value = true\n      } else if (newVal === 0 && oldVal === lastIndex) {\n        isReversed.value = false\n      } else {\n        isReversed.value = newVal < oldVal\n      }\n    })\n\n    provide(VWindowSymbol, {\n      transition,\n      isReversed,\n      transitionCount,\n      transitionHeight,\n      rootRef,\n    })\n\n    const canMoveBack = computed(() => props.continuous || activeIndex.value !== 0)\n    const canMoveForward = computed(() => props.continuous || activeIndex.value !== group.items.value.length - 1)\n\n    function prev () {\n      canMoveBack.value && group.prev()\n    }\n\n    function next () {\n      canMoveForward.value && group.next()\n    }\n\n    const arrows = computed(() => {\n      const arrows = []\n\n      const prevProps = {\n        icon: isRtl.value ? props.nextIcon : props.prevIcon,\n        class: `v-window__${isRtlReverse.value ? 'right' : 'left'}`,\n        onClick: group.prev,\n        ariaLabel: t('$vuetify.carousel.prev'),\n      }\n\n      arrows.push(canMoveBack.value\n        ? slots.prev\n          ? slots.prev({ props: prevProps })\n          : <VBtn { ...prevProps } />\n        : <div />\n      )\n\n      const nextProps = {\n        icon: isRtl.value ? props.prevIcon : props.nextIcon,\n        class: `v-window__${isRtlReverse.value ? 'left' : 'right'}`,\n        onClick: group.next,\n        ariaLabel: t('$vuetify.carousel.next'),\n      }\n\n      arrows.push(canMoveForward.value\n        ? slots.next\n          ? slots.next({ props: nextProps })\n          : <VBtn { ...nextProps } />\n        : <div />\n      )\n\n      return arrows\n    })\n\n    const touchOptions = computed(() => {\n      if (props.touch === false) return props.touch\n\n      const options: TouchHandlers = {\n        left: () => {\n          isRtlReverse.value ? prev() : next()\n        },\n        right: () => {\n          isRtlReverse.value ? next() : prev()\n        },\n        end: ({ originalEvent }) => {\n          originalEvent.stopPropagation()\n        },\n        start: ({ originalEvent }) => {\n          originalEvent.stopPropagation()\n        },\n      }\n\n      return {\n        ...options,\n        ...(props.touch === true ? {} : props.touch),\n      }\n    })\n\n    useRender(() => (\n      <props.tag\n        ref={ rootRef }\n        class={[\n          'v-window',\n          {\n            'v-window--show-arrows-on-hover': props.showArrows === 'hover',\n          },\n          themeClasses.value,\n        ]}\n        v-touch={ touchOptions.value }\n      >\n        <div\n          class=\"v-window__container\"\n          style={{\n            height: transitionHeight.value,\n          }}\n        >\n          { slots.default?.({ group }) }\n\n          { props.showArrows !== false && (\n            <div class=\"v-window__controls\">\n              { arrows.value }\n            </div>\n          )}\n        </div>\n\n        { slots.additional?.({ group }) }\n      </props.tag>\n    ))\n\n    return {\n      group,\n    }\n  },\n})\n\nexport type VWindow = InstanceType<typeof VWindow>\n","// Directives\nimport Touch from '@/directives/touch'\n\n// Composables\nimport { makeGroupItemProps, useGroupItem } from '@/composables/group'\nimport { makeLazyProps, useLazy } from '@/composables/lazy'\nimport { MaybeTransition } from '@/composables/transition'\nimport { useSsrBoot } from '@/composables/ssrBoot'\n\n// Utilities\nimport { computed, inject, nextTick, ref } from 'vue'\nimport { convertToUnit, defineComponent, useRender } from '@/util'\nimport { VWindowGroupSymbol, VWindowSymbol } from './VWindow'\n\nexport const VWindowItem = defineComponent({\n  name: 'VWindowItem',\n\n  directives: {\n    Touch,\n  },\n\n  props: {\n    reverseTransition: {\n      type: [Boolean, String],\n      default: undefined,\n    },\n    transition: {\n      type: [Boolean, String],\n      default: undefined,\n    },\n\n    ...makeGroupItemProps(),\n    ...makeLazyProps(),\n  },\n\n  emits: {\n    'group:selected': (val: { value: boolean }) => true,\n  },\n\n  setup (props, { slots }) {\n    const window = inject(VWindowSymbol)\n    const groupItem = useGroupItem(props, VWindowGroupSymbol)\n    const { isBooted } = useSsrBoot()\n\n    if (!window || !groupItem) throw new Error('[Vuetify] VWindowItem must be used inside VWindow')\n\n    const isTransitioning = ref(false)\n    const hasTransition = computed(() => window.isReversed.value ? props.reverseTransition !== false : props.transition !== false)\n\n    function onAfterTransition () {\n      if (!isTransitioning.value || !window) {\n        return\n      }\n\n      // Finalize transition state.\n      isTransitioning.value = false\n      if (window.transitionCount.value > 0) {\n        window.transitionCount.value -= 1\n\n        // Remove container height if we are out of transition.\n        if (window.transitionCount.value === 0) {\n          window.transitionHeight.value = undefined\n        }\n      }\n    }\n\n    function onBeforeTransition () {\n      if (isTransitioning.value || !window) {\n        return\n      }\n\n      // Initialize transition state here.\n      isTransitioning.value = true\n\n      if (window.transitionCount.value === 0) {\n        // Set initial height for height transition.\n        window.transitionHeight.value = convertToUnit(window.rootRef.value?.clientHeight)\n      }\n\n      window.transitionCount.value += 1\n    }\n\n    function onTransitionCancelled () {\n      onAfterTransition() // This should have the same path as normal transition end.\n    }\n\n    function onEnterTransition (el: Element) {\n      if (!isTransitioning.value) {\n        return\n      }\n\n      nextTick(() => {\n        // Do not set height if no transition or cancelled.\n        if (!hasTransition.value || !isTransitioning.value || !window) {\n          return\n        }\n\n        // Set transition target height.\n        window.transitionHeight.value = convertToUnit(el.clientHeight)\n      })\n    }\n\n    const transition = computed(() => {\n      const name = window.isReversed.value\n        ? props.reverseTransition\n        : props.transition\n\n      return !hasTransition.value ? false : {\n        name: typeof name !== 'string' ? window.transition.value : name,\n        onBeforeEnter: onBeforeTransition,\n        onAfterEnter: onAfterTransition,\n        onEnterCancelled: onTransitionCancelled,\n        onBeforeLeave: onBeforeTransition,\n        onAfterLeave: onAfterTransition,\n        onLeaveCancelled: onTransitionCancelled,\n        onEnter: onEnterTransition,\n      }\n    })\n\n    const { hasContent } = useLazy(props, groupItem.isSelected)\n\n    useRender(() => (\n      <MaybeTransition transition={ isBooted.value && transition.value } >\n        <div\n          class={[\n            'v-window-item',\n            groupItem.selectedClass.value,\n          ]}\n          v-show={ groupItem.isSelected.value }\n        >\n          { hasContent.value && slots.default?.() }\n        </div>\n      </MaybeTransition>\n    ))\n\n    return {}\n  },\n})\n\nexport type VWindowItem = InstanceType<typeof VWindowItem>\n","// Types\nimport type {\n  DirectiveBinding,\n  ObjectDirective,\n} from 'vue'\n\n// Utilities\nimport { keys } from '@/util'\n\nexport interface TouchHandlers {\n  start?: (wrapperEvent: { originalEvent: TouchEvent } & TouchWrapper) => void\n  end?: (wrapperEvent: { originalEvent: TouchEvent } & TouchWrapper) => void\n  move?: (wrapperEvent: { originalEvent: TouchEvent } & TouchWrapper) => void\n  left?: (wrapper: TouchWrapper) => void\n  right?: (wrapper: TouchWrapper) => void\n  up?: (wrapper: TouchWrapper) => void\n  down?: (wrapper: TouchWrapper) => void\n}\n\nexport interface TouchWrapper extends TouchHandlers {\n  touchstartX: number\n  touchstartY: number\n  touchmoveX: number\n  touchmoveY: number\n  touchendX: number\n  touchendY: number\n  offsetX: number\n  offsetY: number\n}\n\nexport interface TouchValue extends TouchHandlers {\n  parent?: boolean\n  options?: AddEventListenerOptions\n}\n\nexport interface TouchStoredHandlers {\n  touchstart: (e: TouchEvent) => void\n  touchend: (e: TouchEvent) => void\n  touchmove: (e: TouchEvent) => void\n}\n\nexport interface TouchDirectiveBinding extends Omit<DirectiveBinding, 'value'> {\n  value?: TouchValue\n}\n\nconst handleGesture = (wrapper: TouchWrapper) => {\n  const { touchstartX, touchendX, touchstartY, touchendY } = wrapper\n  const dirRatio = 0.5\n  const minDistance = 16\n  wrapper.offsetX = touchendX - touchstartX\n  wrapper.offsetY = touchendY - touchstartY\n\n  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {\n    wrapper.left && (touchendX < touchstartX - minDistance) && wrapper.left(wrapper)\n    wrapper.right && (touchendX > touchstartX + minDistance) && wrapper.right(wrapper)\n  }\n\n  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {\n    wrapper.up && (touchendY < touchstartY - minDistance) && wrapper.up(wrapper)\n    wrapper.down && (touchendY > touchstartY + minDistance) && wrapper.down(wrapper)\n  }\n}\n\nfunction touchstart (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchstartX = touch.clientX\n  wrapper.touchstartY = touch.clientY\n\n  wrapper.start?.({ originalEvent: event, ...wrapper })\n}\n\nfunction touchend (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchendX = touch.clientX\n  wrapper.touchendY = touch.clientY\n\n  wrapper.end?.({ originalEvent: event, ...wrapper })\n\n  handleGesture(wrapper)\n}\n\nfunction touchmove (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchmoveX = touch.clientX\n  wrapper.touchmoveY = touch.clientY\n\n  wrapper.move?.({ originalEvent: event, ...wrapper })\n}\n\nfunction createHandlers (value: TouchHandlers = {}): TouchStoredHandlers {\n  const wrapper = {\n    touchstartX: 0,\n    touchstartY: 0,\n    touchendX: 0,\n    touchendY: 0,\n    touchmoveX: 0,\n    touchmoveY: 0,\n    offsetX: 0,\n    offsetY: 0,\n    left: value.left,\n    right: value.right,\n    up: value.up,\n    down: value.down,\n    start: value.start,\n    move: value.move,\n    end: value.end,\n  }\n\n  return {\n    touchstart: (e: TouchEvent) => touchstart(e, wrapper),\n    touchend: (e: TouchEvent) => touchend(e, wrapper),\n    touchmove: (e: TouchEvent) => touchmove(e, wrapper),\n  }\n}\n\nfunction mounted (el: HTMLElement, binding: TouchDirectiveBinding) {\n  const value = binding.value\n  const target = value?.parent ? el.parentElement : el\n  const options = value?.options ?? { passive: true }\n  const uid = binding.instance?.$.uid // TODO: use custom uid generator\n\n  if (!target || !uid) return\n\n  const handlers = createHandlers(binding.value)\n\n  target._touchHandlers = target._touchHandlers ?? Object.create(null)\n  target._touchHandlers![uid] = handlers\n\n  keys(handlers).forEach(eventName => {\n    target.addEventListener(eventName, handlers[eventName], options)\n  })\n}\n\nfunction unmounted (el: HTMLElement, binding: TouchDirectiveBinding) {\n  const target = binding.value?.parent ? el.parentElement : el\n  const uid = binding.instance?.$.uid\n\n  if (!target?._touchHandlers || !uid) return\n\n  const handlers = target._touchHandlers[uid]\n\n  keys(handlers).forEach(eventName => {\n    target.removeEventListener(eventName, handlers[eventName])\n  })\n\n  delete target._touchHandlers[uid]\n}\n\nexport const Touch: ObjectDirective = {\n  mounted,\n  unmounted,\n}\n\nexport default Touch\n"],"names":["highlightResult","text","matches","length","Array","isArray","Error","substr","VAutocomplete","genericComponent","name","props","search","String","makeFilterProps","filterKeys","makeSelectProps","makeTransitionProps","transition","emits","val","setup","slots","_ref","t","useLocale","vTextFieldRef","ref","isFocused","isPristine","menu","useProxiedModel","items","transformIn","transformOut","useItems","model","v","wrapInArray","transformed","multiple","filteredItems","useFilter","computed","value","undefined","selections","map","find","item","selected","selection","onClear","e","openOnClear","onClickControl","hideNoData","onKeydown","includes","key","onInput","target","onAfterLeave","isSelecting","select","index","findIndex","splice","title","nextTick","watch","at","_selections$value$at","useRender","hasChips","chips","chip","modelValue","menuIcon","default","$event","eager","menuProps","preventDefault","_slots$noData2","noDataText","_ref2","_slots$item2","mergeProps","onClick","prepend","_ref3","isSelected","hideSelected","_search$value","onChipClose","stopPropagation","slotProps","VChip","closable","closableChips","size","forwardRefs","VTab","defineComponent","fixed","Boolean","icon","Function","Object","prependIcon","IconValue","appendIcon","stacked","ripple","type","color","sliderColor","hideSlider","direction","makeTagProps","makeRouterProps","makeGroupItemProps","selectedClass","makeThemeProps","attrs","textColorClasses","sliderColorClasses","textColorStyles","sliderColorStyles","useTextColor","isHorizontal","rootEl","sliderEl","updateSlider","prevEl","_rootEl$value","$el","parentElement","_rootEl$value$$el$par","querySelector","nextEl","getComputedStyle","prevBox","getBoundingClientRect","nextBox","xy","XY","rightBottom","widthHeight","prevPos","nextPos","delta","origin","Math","sign","abs","scale","max","initialScale","sigma","animate","backgroundColor","transform","transformOrigin","fill","duration","easing","standardEasing","btnProps","pick","VTabsSymbol","bias","c","x","calculateUpdatedOffset","selectedElement","containerSize","contentSize","isRtl","currentScrollOffset","clientSize","clientWidth","clientHeight","offsetStart","offsetLeft","offsetTop","adjustedOffsetStart","totalSize","itemOffset","additionalOffset","min","calculateCenteredOffset","offsetCentered","VSlideGroupSymbol","Symbol","for","VSlideGroup","centerActive","symbol","nextIcon","prevIcon","showArrows","validator","makeGroupProps","useRtl","mobile","useDisplay","group","useGroup","isOverflowing","scrollOffset","resizeRef","containerRef","contentRect","containerRect","useResizeObserver","contentRef","firstSelectedIndex","id","lastSelectedIndex","IN_BROWSER","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","children","disableTransition","startTouch","startOffset","onTouchstart","touches","onTouchmove","onTouchend","maxScrollOffset","onScroll","scrollLeft","onFocusin","el","composedPath","onFocusout","onFocus","relatedTarget","_contentRef$value","contains","focus","location","_contentRef$value$que","nextElementSibling","_contentRef$value$que2","previousElementSibling","firstElementChild","lastElementChild","focusable","querySelectorAll","filter","hasAttribute","scrollTo","newAbosluteOffset","clamp","contentStyles","scrollAmount","willChange","next","prev","hasAffixes","hasPrev","hasNext","_slots$prev2","_slots$default","_slots$next2","parseItems","VTabs","alignWithTitle","fixedTabs","centered","grow","height","Number","optional","end","makeDensityProps","parsedItems","densityClasses","useDensity","backgroundColorClasses","backgroundColorStyles","useBackgroundColor","toRef","provideDefaults","VWindowSymbol","VWindowGroupSymbol","VWindow","directives","Touch","continuous","reverse","touch","disabled","mandatory","themeClasses","provideTheme","rootRef","isRtlReverse","isReversed","axis","transitionCount","transitionHeight","activeIndex","newVal","oldVal","itemsLength","lastIndex","provide","canMoveBack","canMoveForward","arrows","prevProps","class","ariaLabel","push","nextProps","touchOptions","options","left","right","originalEvent","start","additional","_slots$additional","VWindowItem","reverseTransition","makeLazyProps","window","inject","groupItem","useGroupItem","isBooted","useSsrBoot","isTransitioning","hasTransition","onAfterTransition","onBeforeTransition","convertToUnit","_window$rootRef$value","onTransitionCancelled","onEnterTransition","onBeforeEnter","onAfterEnter","onEnterCancelled","onBeforeLeave","onLeaveCancelled","onEnter","hasContent","useLazy","handleGesture","wrapper","touchstartX","touchendX","touchstartY","touchendY","dirRatio","minDistance","offsetX","offsetY","up","down","touchstart","event","changedTouches","clientX","clientY","touchend","touchmove","touchmoveX","touchmoveY","move","createHandlers","mounted","binding","parent","passive","uid","instance","_binding$instance","$","handlers","_touchHandlers","create","keys","forEach","eventName","addEventListener","unmounted","_binding$instance2","removeEventListener"],"sourceRoot":""}